//----------------------------------------------------------------------------//
//---------------------------------|  V  E  |---------------------------------//
//----------------------------------------------------------------------------//
#pragma once
//----------------------------------------------------------------------------//
#if VE_VULKAN
//----------------------------------------------------------------------------//
#include "systems/render/api/vulkan/ve_vulkan_resource.h"
#include "systems/render/api/vulkan/ve_vulkan_queue.h"
//----------------------------------------------------------------------------//
START_NAMESPACE(ve)
START_NAMESPACE(render)
//----------------------------------------------------------------------------//
// Forward declarations.
class Display;

//----------------------------------------------------------------------------//
// Vulkan device.
class PlatformDevice
{
public:
	// Constructor.
	PlatformDevice();

	// Destructor.
	~PlatformDevice();

	// Move constructor.
	PlatformDevice(PlatformDevice&&) noexcept;

	// Move operator.
	PlatformDevice& operator =(PlatformDevice&&) noexcept;

	// Copying is prohibited.
	PlatformDevice(const PlatformDevice&) = delete;
	PlatformDevice& operator =(const PlatformDevice&) = delete;

protected:
	VkRc<vk::instance> instance;
	VkRc<vk::dbg_messenger> dbg_messenger;
	VkRc<vk::device> device;

	// main queue must support all types of commands:
	// graphics, compute, transfer and present
	VkRc<vk::queue> main_queue;

	// command pool for all command buffers created with CmdBufferInfo::usage_once
	// flag and that must be reset every frame by calling ResetCmdPool() method.
	VkRc<vk::cmd_pool> dynamic_cmd_pool;

	// physical device that is used for rendering
	VkPhysicalDevice gpu;

	// queue families available on physical device
	ut::Map<vulkan_queue::FamilyType, vulkan_queue::Family> queue_families;

	// memory properties
	VkPhysicalDeviceMemoryProperties memory_properties;

	// Combines the requirements of the buffer and application requirements
	// to find the right type of memory to use.
	//    @param type_bits - bitmask that contains one bit set for every
	//                       supported memory type for the resource.
	//    @param requirements_mask - requirements flags that must be set for
	//                               the desired memory.
	//    @return - id of the memory or nothing if failed.
	ut::Optional<uint32_t> FindMemoryTypeFromProperties(uint32_t type_bits,
	                                                    VkFlags requirements_mask);

	// Creates vulkan buffer.
	//    @param size - buffer size in bytes.
	//    @param usage - buffer usage flags.
	//    @return - buffer handle or error if failed.
	ut::Result<VkBuffer, ut::Error> CreateVulkanBuffer(VkDeviceSize size,
	                                                   VkBufferUsageFlags usage);

	// Allocates gpu memory for the specified buffer.
	//    @param buffer - buffer handle.
	//    @param properties - memory properties.
	//    @return - memory handle or error if failed.
	ut::Result<VkDeviceMemory, ut::Error> AllocateBufferMemory(VkBuffer buffer,
	                                                           VkMemoryPropertyFlags properties);

	// Copies contents of source buffer to the destination buffer.
	//    @param src - source buffer handle.
	//    @param dst - destination buffer handle.
	//    @param size - size of the data to be copied in bytes.
	//    @return - optional error if failed.
	ut::Optional<ut::Error> CopyVulkanBuffer(VkBuffer src, VkBuffer dst, VkDeviceSize size);

	// Creates command pool.
	ut::Result<VkCommandPool, ut::Error> CreateCmdPool(VkCommandPoolCreateFlags flags);

private:
	// Creates vkInstance object.
	static VkInstance CreateVulkanInstance();

	// Vulkan message callback.
	static VKAPI_ATTR VkBool32 VKAPI_CALL VulkanDbgCallback(VkDebugUtilsMessageSeverityFlagBitsEXT,
	                                                        VkDebugUtilsMessageTypeFlagsEXT,
	                                                        const VkDebugUtilsMessengerCallbackDataEXT*,
	                                                        void*);

	// Returns 'true' if system supports validation layer.
	static bool CheckValidationLayerSupport();

	// Returns physical device that suits best.
	static ut::Optional<VkPhysicalDevice> SelectPreferredPhysicalDevice(const ut::Array<VkPhysicalDevice>& devices);

	// Returns an array of physical devices.
	ut::Array<VkPhysicalDevice> EnumeratePhysicalDevices();

	// Returns a map of queue-type/family-id values.
	ut::Map<vulkan_queue::FamilyType, vulkan_queue::Family> GetQueueFamilies(VkPhysicalDevice gpu);

	// Create intercepter for messages generated by Vulkan instance.
	VkDebugUtilsMessengerEXT CreateDbgMessenger();

	// Creates VkDevice object.
	VkDevice CreateVulkanDevice();

	// Creates desired queue.
	VkRc<vk::queue> CreateQueue(vulkan_queue::FamilyType family_type, uint32_t id);
};
//----------------------------------------------------------------------------//
END_NAMESPACE(render)
END_NAMESPACE(ve)
//----------------------------------------------------------------------------//
#endif // VE_VULKAN
//----------------------------------------------------------------------------//
//----------------------------------------------------------------------------//
//----------------------------------------------------------------------------//
